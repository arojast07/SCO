{"version":3,"file":"clienteService-DoS4zFTf.js","sources":["../../src/services/clienteService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase';\nimport type { Cliente } from '../types/cliente';\n\nexport interface ClienteFilters {\n  search?: string;\n  tipo?: string;\n  activo?: boolean;\n}\n\nexport const getClientes = async (filters: ClienteFilters = {}, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { data: [], error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    let query = supabase\n      .from('clientes')\n      .select(`\n        *,\n        pais:paises(nombre),\n        provincia:provincias(nombre),\n        canton:cantones(nombre),\n        distrito:distritos(nombre)\n      `)\n      .eq('tienda_id', currentStore.id); // FILTRO OBLIGATORIO POR TIENDA\n\n    if (filters.search) {\n      query = query.or(`nombre.ilike.%${filters.search}%,correo_principal.ilike.%${filters.search}%,telefono.ilike.%${filters.search}%`);\n    }\n\n    if (filters.tipo) {\n      query = query.eq('tipo_cliente', filters.tipo);\n    }\n\n    if (filters.activo !== undefined) {\n      query = query.eq('activo', filters.activo);\n    }\n\n    query = query.order('created_at', { ascending: false });\n\n    const { data, error } = await query;\n\n    return { data: data || [], error };\n  } catch (error) {\n    console.error('Error fetching clientes:', error);\n    return { data: [], error };\n  }\n};\n\nexport const getClienteById = async (id: string, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { data: null, error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    const { data, error } = await supabase\n      .from('clientes')\n      .select(`\n        *,\n        pais:paises(nombre),\n        provincia:provincias(nombre),\n        canton:cantones(nombre),\n        distrito:distritos(nombre)\n      `)\n      .eq('id', id)\n      .eq('tienda_id', currentStore.id) // FILTRO OBLIGATORIO POR TIENDA\n      .single();\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error fetching cliente:', error);\n    return { data: null, error };\n  }\n};\n\nexport const createCliente = async (cliente: Omit<Cliente, 'id' | 'created_at' | 'updated_at'>, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { data: null, error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    const { data, error } = await supabase\n      .from('clientes')\n      .insert([{\n        ...cliente,\n        tienda_id: currentStore.id // INCLUIR TIENDA_ID OBLIGATORIO\n      }])\n      .select()\n      .single();\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error creating cliente:', error);\n    return { data: null, error };\n  }\n};\n\nexport const updateCliente = async (id: string, cliente: Partial<Cliente>, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { data: null, error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    const { data, error } = await supabase\n      .from('clientes')\n      .update(cliente)\n      .eq('id', id)\n      .eq('tienda_id', currentStore.id) // FILTRO OBLIGATORIO POR TIENDA\n      .select()\n      .single();\n\n    return { data, error };\n  } catch (error) {\n    console.error('Error updating cliente:', error);\n    return { data: null, error };\n  }\n};\n\nexport const deleteCliente = async (id: string, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    const { error } = await supabase\n      .from('clientes')\n      .delete()\n      .eq('id', id)\n      .eq('tienda_id', currentStore.id); // FILTRO OBLIGATORIO POR TIENDA\n\n    return { error };\n  } catch (error) {\n    console.error('Error deleting cliente:', error);\n    return { error };\n  }\n};\n\nexport const buscarClientes = async (search: string, currentStore: { id: string } | null) => {\n  if (!currentStore) {\n    return { data: [], error: { message: 'No hay tienda seleccionada' } };\n  }\n\n  try {\n    const { data, error } = await supabase\n      .from('clientes')\n      .select('id, nombre, correo_principal, tipo_cliente')\n      .eq('tienda_id', currentStore.id) // FILTRO OBLIGATORIO POR TIENDA\n      .or(`nombre.ilike.%${search}%,correo_principal.ilike.%${search}%,telefono.ilike.%${search}%`)\n      .eq('activo', true)\n      .limit(10);\n\n    return { data: data || [], error };\n  } catch (error) {\n    console.error('Error searching clientes:', error);\n    return { data: [], error };\n  }\n};\n\n// Funciones auxiliares para ClienteService\nconst obtenerClientes = async (filters: ClienteFilters = {}) => {\n  try {\n    // Obtener tienda actual del usuario\n    const { data: { user } } = await supabase.auth.getUser();\n    if (!user) {\n      throw new Error('Usuario no autenticado');\n    }\n\n    // Obtener tienda actual del usuario\n    const { data: tiendaActual } = await supabase\n      .from('usuario_tienda_actual')\n      .select('tienda_id')\n      .eq('usuario_id', user.id)\n      .single();\n\n    if (!tiendaActual?.tienda_id) {\n      console.warn('‚ö†Ô∏è Usuario sin tienda asignada');\n      return [];\n    }\n\n    let query = supabase\n      .from('clientes')\n      .select(`\n        *,\n        pais:paises(nombre),\n        provincia:provincias(nombre),\n        canton:cantones(nombre),\n        distrito:distritos(nombre)\n      `)\n      .eq('tienda_id', tiendaActual.tienda_id)\n      .eq('activo', true);\n\n    if (filters.search) {\n      query = query.or(`nombre_razon_social.ilike.%${filters.search}%,identificacion.ilike.%${filters.search}%,correo_principal.ilike.%${filters.search}%`);\n    }\n\n    if (filters.tipo) {\n      query = query.eq('tipo_identificacion', filters.tipo);\n    }\n\n    query = query.order('nombre_razon_social');\n\n    const { data, error } = await query;\n\n    if (error) {\n      console.error('‚ùå Error obteniendo clientes:', error);\n      throw error;\n    }\n\n    return data || [];\n  } catch (error) {\n    console.error('‚ùå Error en obtenerClientes:', error);\n    throw error;\n  }\n};\n\nconst obtenerProvincias = async () => {\n  try {\n    const { data, error } = await supabase\n      .from('provincias')\n      .select('*')\n      .order('nombre');\n    \n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error obteniendo provincias:', error);\n    return [];\n  }\n};\n\nconst obtenerCantones = async (provinciaId: number) => {\n  try {\n    const { data, error } = await supabase\n      .from('cantones')\n      .select('*')\n      .eq('provincia_id', provinciaId)\n      .order('nombre');\n    \n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error obteniendo cantones:', error);\n    return [];\n  }\n};\n\nconst obtenerDistritos = async (cantonId: number) => {\n  try {\n    console.log('üîç Cargando distritos para cant√≥n:', cantonId);\n    \n    // Agregar timeout de 10 segundos\n    const timeoutPromise = new Promise((_, reject) => \n      setTimeout(() => reject(new Error('Timeout al cargar distritos')), 10000)\n    );\n    \n    const queryPromise = supabase\n      .from('distritos')\n      .select('*')\n      .eq('canton_id', cantonId)\n      .order('nombre');\n    \n    const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;\n    \n    if (error) {\n      console.error('‚ùå Error obteniendo distritos:', error);\n      throw error;\n    }\n    \n    console.log(`‚úÖ Distritos cargados: ${data?.length || 0} registros`);\n    return data || [];\n  } catch (error: any) {\n    console.error('‚ùå Error en obtenerDistritos:', error);\n    \n    // Si hay timeout o error, retornar array vac√≠o en lugar de fallar\n    if (error.message === 'Timeout al cargar distritos') {\n      console.warn('‚ö†Ô∏è Timeout al cargar distritos, retornando array vac√≠o');\n    }\n    \n    return [];\n  }\n};\n\nconst obtenerPaises = async () => {\n  try {\n    const { data, error } = await supabase\n      .from('paises')\n      .select('*')\n      .order('nombre');\n    \n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error obteniendo pa√≠ses:', error);\n    return [];\n  }\n};\n\nconst obtenerActividadesEconomicas = async () => {\n  try {\n    const { data, error } = await supabase\n      .from('actividades_economicas')\n      .select('*')\n      .order('codigo');\n    \n    if (error) throw error;\n    return data || [];\n  } catch (error) {\n    console.error('Error obteniendo actividades econ√≥micas:', error);\n    return [];\n  }\n};\n\nconst validarIdentificacion = (tipo: string, identificacion: string): boolean => {\n  const numero = identificacion.replace(/\\D/g, '');\n  \n  switch (tipo) {\n    case 'cedula_fisica':\n      return numero.length === 9;\n    case 'cedula_juridica':\n      return numero.length === 10;\n    case 'dimex':\n      return numero.length >= 11 && numero.length <= 12;\n    case 'nite':\n      return numero.length === 10;\n    case 'pasaporte':\n      return identificacion.length >= 6 && identificacion.length <= 20;\n    default:\n      return false;\n  }\n};\n\nconst validarEmail = (email: string): boolean => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\n\nconst validarTelefono = (telefono: string): boolean => {\n  const numero = telefono.replace(/\\D/g, '');\n  return numero.length >= 8 && numero.length <= 15;\n};\n\n// Exportar ClienteService como objeto\nexport const ClienteService = {\n  obtenerClientes,\n  obtenerProvincias,\n  obtenerCantones,\n  obtenerDistritos,\n  obtenerPaises,\n  obtenerActividadesEconomicas,\n  validarIdentificacion,\n  validarEmail,\n  validarTelefono,\n  buscarClientes: async (search: string) => {\n    try {\n      // Obtener usuario autenticado\n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) throw new Error('Usuario no autenticado');\n\n      // Obtener tienda actual del usuario\n      const { data: tiendaActual, error: tiendaError } = await supabase\n        .from('usuario_tienda_actual')\n        .select('tienda_id')\n        .eq('usuario_id', user.id)\n        .single();\n\n      if (tiendaError) throw tiendaError;\n\n      // Buscar clientes por nombre o identificaci√≥n\n      const { data, error } = await supabase\n        .from('clientes')\n        .select('id, nombre_razon_social, identificacion, tipo_identificacion')\n        .eq('tienda_id', tiendaActual.tienda_id)\n        .or(`nombre_razon_social.ilike.%${search}%,identificacion.ilike.%${search}%`)\n        .eq('activo', true)\n        .limit(10);\n\n      if (error) throw error;\n      return data || [];\n    } catch (error) {\n      console.error('Error buscando clientes:', error);\n      return [];\n    }\n  },\n\n  crearCliente: async (clienteData: any) => {\n    try {\n      const { data: session } = await supabase.auth.getSession();\n      if (!session.session?.user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Obtener la tienda actual del usuario\n      const { data: usuarioTienda } = await supabase\n        .from('usuario_tienda_actual')\n        .select('tienda_id')\n        .eq('usuario_id', session.session.user.id)\n        .single();\n\n      if (!usuarioTienda) {\n        throw new Error('No se pudo determinar la tienda actual');\n      }\n\n      // Limpiar campos de fecha vac√≠os (convertir \"\" a null)\n      const datosLimpios = { ...clienteData };\n      if (datosLimpios.exoneracion_vencimiento === '') {\n        datosLimpios.exoneracion_vencimiento = null;\n      }\n      if (datosLimpios.hacienda_ultimo_intento === '') {\n        datosLimpios.hacienda_ultimo_intento = null;\n      }\n\n      // Preparar datos del cliente\n      const nuevoCliente = {\n        ...datosLimpios,\n        tienda_id: usuarioTienda.tienda_id\n      };\n\n      const { data, error } = await supabase\n        .from('clientes')\n        .insert([nuevoCliente])\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error creando cliente:', error);\n        throw new Error('Error al crear el cliente: ' + error.message);\n      }\n\n      return data;\n    } catch (error: any) {\n      console.error('Error en crearCliente:', error);\n      throw error;\n    }\n  },\n\n  actualizarCliente: async (id: string, clienteData: any) => {\n    try {\n      const { data: session } = await supabase.auth.getSession();\n      if (!session.session?.user) {\n        throw new Error('Usuario no autenticado');\n      }\n\n      // Obtener la tienda actual del usuario\n      const { data: usuarioTienda } = await supabase\n        .from('usuario_tienda_actual')\n        .select('tienda_id')\n        .eq('usuario_id', session.session.user.id)\n        .single();\n\n      if (!usuarioTienda) {\n        throw new Error('No se pudo determinar la tienda actual');\n      }\n\n      // Limpiar campos de fecha vac√≠os (convertir \"\" a null)\n      const datosLimpios = { ...clienteData };\n      if (datosLimpios.exoneracion_vencimiento === '') {\n        datosLimpios.exoneracion_vencimiento = null;\n      }\n      if (datosLimpios.hacienda_ultimo_intento === '') {\n        datosLimpios.hacienda_ultimo_intento = null;\n      }\n\n      const { data, error } = await supabase\n        .from('clientes')\n        .update(datosLimpios)\n        .eq('id', id)\n        .eq('tienda_id', usuarioTienda.tienda_id)\n        .select()\n        .single();\n\n      if (error) {\n        console.error('Error actualizando cliente:', error);\n        throw new Error('Error al actualizar el cliente: ' + error.message);\n      }\n\n      return data;\n    } catch (error: any) {\n      console.error('Error en actualizarCliente:', error);\n      throw error;\n    }\n  }\n};\n\n// Funciones para HaciendaService\nconst validarIdentificacionHacienda = async (identificacion: string) => {\n  try {\n    // Simulaci√≥n de validaci√≥n con Hacienda\n    // En producci√≥n, aqu√≠ ir√≠a la llamada real a la API de Hacienda\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    return {\n      valido: true,\n      mensaje: 'Identificaci√≥n v√°lida seg√∫n Hacienda'\n    };\n  } catch (error) {\n    return {\n      valido: false,\n      mensaje: 'Error al validar con Hacienda'\n    };\n  }\n};\n\n// Exportar HaciendaService como objeto\nexport const HaciendaService = {\n  validarIdentificacion: validarIdentificacionHacienda\n};\n"],"names":["obtenerClientes","filters","user","supabase","tiendaActual","query","data","error","obtenerProvincias","obtenerCantones","provinciaId","obtenerDistritos","cantonId","timeoutPromise","_","reject","queryPromise","obtenerPaises","obtenerActividadesEconomicas","validarIdentificacion","tipo","identificacion","numero","validarEmail","email","validarTelefono","telefono","ClienteService","search","tiendaError","clienteData","session","usuarioTienda","datosLimpios","nuevoCliente","id","validarIdentificacionHacienda","resolve","HaciendaService"],"mappings":"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"}